# FTS5 + Alembic Integration Guide

## Overview

This document explains how ACARS Hub integrates SQLite FTS5 (Full-Text Search) with Alembic migrations, replacing the legacy `upgrade_db.py` script while maintaining identical functionality.

## The Challenge

**Problem**: SQLite FTS5 virtual tables are not supported by standard ORMs (including SQLAlchemy/Alembic)

**Why ORMs Don't Handle FTS**:

- FTS5 is SQLite-specific (not standard SQL)
- Virtual tables use non-standard syntax
- Triggers reference special FTS5 commands (`'delete'`, `'rebuild'`)
- ORMs can't autogenerate migrations for virtual tables

**Legacy Solution**: `upgrade_db.py` script with manual FTS setup

**New Solution**: Alembic migrations with raw SQL via `op.execute()`

---

## How It Works

### Alembic's Raw SQL Support

Alembic provides `op.execute()` for executing arbitrary SQL that the ORM doesn't understand:

```python
from alembic import op

def upgrade():
    # Execute any SQL statement
    op.execute("CREATE VIRTUAL TABLE messages_fts USING fts5(...)")
    op.execute("CREATE TRIGGER messages_fts_insert ...")
```

This gives us:

- ✅ Full SQLite FTS5 access (no ORM limitations)
- ✅ Version control (migrations tracked in history)
- ✅ Rollback support (downgrade functions)
- ✅ Testing (can test migrations before production)

---

## FTS Migration Implementation

### Migration File Structure

**Location**: `rootfs/webapp/migrations/versions/003_enable_fts.py`

**Generated by**: `alembic revision -m "Enable FTS5 full-text search"`

**Contents**:

```python
"""Enable FTS5 full-text search on messages table

Revision ID: 003
Revises: 002
Create Date: 2026-02-01 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic
revision = '003'
down_revision = '002'
branch_labels = None
depends_on = None

# Columns to include in FTS index (from legacy upgrade_db.py)
FTS_COLUMNS = [
    'station_id',
    'toaddr',
    'fromaddr',
    'depa',
    'dsta',
    'eta',
    'gtout',
    'gtin',
    'wloff',
    'wlin',
    'text',
    'tail',
    'flight',
    'icao',
    'freq',
    'ack',
    'mode',
    'label',
    'block_id',
    'msgno',
]

def upgrade():
    """Create FTS5 virtual table and sync triggers"""

    column_list = ', '.join(FTS_COLUMNS)

    # Step 1: Create FTS5 virtual table
    op.execute(f"""
        CREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING fts5(
            {column_list},
            content=messages,
            content_rowid=id
        )
    """)

    # Step 2: Create INSERT trigger
    new_columns = ', '.join(f'new.{c}' for c in FTS_COLUMNS)
    op.execute(f"""
        CREATE TRIGGER IF NOT EXISTS messages_fts_insert
        AFTER INSERT ON messages
        BEGIN
            INSERT INTO messages_fts (rowid, {column_list})
            VALUES (new.id, {new_columns});
        END
    """)

    # Step 3: Create DELETE trigger
    old_columns = ', '.join(f'old.{c}' for c in FTS_COLUMNS)
    op.execute(f"""
        CREATE TRIGGER IF NOT EXISTS messages_fts_delete
        AFTER DELETE ON messages
        BEGIN
            INSERT INTO messages_fts (messages_fts, rowid, {column_list})
            VALUES ('delete', old.id, {old_columns});
        END
    """)

    # Step 4: Create UPDATE trigger
    op.execute(f"""
        CREATE TRIGGER IF NOT EXISTS messages_fts_update
        AFTER UPDATE ON messages
        BEGIN
            INSERT INTO messages_fts (messages_fts, rowid, {column_list})
            VALUES ('delete', old.id, {old_columns});
            INSERT INTO messages_fts (rowid, {column_list})
            VALUES (new.id, {new_columns});
        END
    """)

    # Step 5: Populate FTS table with existing messages
    op.execute("""
        INSERT INTO messages_fts(messages_fts) VALUES ('rebuild')
    """)

def downgrade():
    """Remove FTS5 virtual table and triggers"""

    # Drop triggers (must drop before virtual table)
    op.execute("DROP TRIGGER IF EXISTS messages_fts_insert")
    op.execute("DROP TRIGGER IF EXISTS messages_fts_delete")
    op.execute("DROP TRIGGER IF EXISTS messages_fts_update")

    # Drop virtual table
    op.execute("DROP TABLE IF EXISTS messages_fts")
```

---

## FTS5 Technical Details

### Virtual Table Syntax

**What is a Virtual Table?**

- Special SQLite feature for custom data access
- FTS5 is a built-in virtual table module for full-text search
- Not a real table - data stored in shadow tables (`*_data`, `*_idx`, `*_content`, etc.)

**Content Table Pattern**:

```sql
CREATE VIRTUAL TABLE messages_fts USING fts5(
    text,           -- Searchable columns
    tail,
    flight,
    content=messages,      -- Source table
    content_rowid=id       -- Link to source table's primary key
)
```

This creates an **external content table** - FTS index is separate from source data.

### Trigger Synchronization

**Why Triggers?**

- External content tables don't auto-sync with source table
- Triggers keep FTS index in sync with `messages` table
- Required for INSERT, UPDATE, DELETE operations

**INSERT Trigger**:

```sql
CREATE TRIGGER messages_fts_insert AFTER INSERT ON messages
BEGIN
    INSERT INTO messages_fts (rowid, text, tail, flight)
    VALUES (new.id, new.text, new.tail, new.flight);
END
```

When a row is inserted into `messages`, the trigger inserts corresponding FTS entry.

**DELETE Trigger**:

```sql
CREATE TRIGGER messages_fts_delete AFTER DELETE ON messages
BEGIN
    INSERT INTO messages_fts (messages_fts, rowid, text, tail, flight)
    VALUES ('delete', old.id, old.text, old.tail, old.flight);
END
```

The `'delete'` command tells FTS5 to remove the entry with `rowid=old.id`.

**UPDATE Trigger**:

```sql
CREATE TRIGGER messages_fts_update AFTER UPDATE ON messages
BEGIN
    INSERT INTO messages_fts (messages_fts, rowid, text, tail, flight)
    VALUES ('delete', old.id, old.text, old.tail, old.flight);
    INSERT INTO messages_fts (rowid, text, tail, flight)
    VALUES (new.id, new.text, new.tail, new.flight);
END
```

Updates = delete old entry + insert new entry.

### Rebuild Command

**Populating Existing Data**:

```sql
INSERT INTO messages_fts(messages_fts) VALUES ('rebuild')
```

The `'rebuild'` command:

1. Scans the `content=messages` table
2. Extracts all rows
3. Populates FTS index
4. Used after creating FTS table or after data corruption

---

## Comparison: upgrade_db.py vs Alembic

### Legacy Approach (upgrade_db.py)

**File**: `rootfs/scripts/upgrade_db.py`

**Function**: `enable_fts(db, table, columns)`

**Behavior**:

```python
def enable_fts(db: Connection, table: str, columns: List[str]):
    # Create virtual table
    db.executescript("""
        CREATE VIRTUAL TABLE {table}_fts USING fts5(...)
    """)

    # Create triggers
    db.executescript("""
        CREATE TRIGGER {table}_fts_insert ...
        CREATE TRIGGER {table}_fts_delete ...
        CREATE TRIGGER {table}_fts_update ...
    """)

    # Rebuild FTS index
    db.executescript('INSERT INTO messages_fts(messages_fts) VALUES ("rebuild")')
```

**Issues**:

- ❌ No version control
- ❌ No rollback capability
- ❌ Difficult to test
- ❌ Not idempotent (fails if FTS already exists)
- ❌ Manual execution required
- ❌ No team collaboration (no merge conflict resolution)

### New Approach (Alembic)

**File**: `migrations/versions/003_enable_fts.py`

**Function**: `upgrade()` / `downgrade()`

**Behavior**:

```python
def upgrade():
    """Apply FTS migration"""
    op.execute("CREATE VIRTUAL TABLE IF NOT EXISTS messages_fts ...")
    op.execute("CREATE TRIGGER IF NOT EXISTS messages_fts_insert ...")
    op.execute("CREATE TRIGGER IF NOT EXISTS messages_fts_delete ...")
    op.execute("CREATE TRIGGER IF NOT EXISTS messages_fts_update ...")
    op.execute("INSERT INTO messages_fts(messages_fts) VALUES ('rebuild')")

def downgrade():
    """Rollback FTS migration"""
    op.execute("DROP TRIGGER IF EXISTS messages_fts_insert")
    op.execute("DROP TRIGGER IF EXISTS messages_fts_delete")
    op.execute("DROP TRIGGER IF EXISTS messages_fts_update")
    op.execute("DROP TABLE IF EXISTS messages_fts")
```

**Benefits**:

- ✅ Version controlled (Git tracks migration files)
- ✅ Rollback support (`alembic downgrade -1`)
- ✅ Testable (test database migrations before production)
- ✅ Idempotent (`IF NOT EXISTS` clauses)
- ✅ Automatic execution (`alembic upgrade head`)
- ✅ Team collaboration (Alembic handles migration branches)

---

## Migration Workflow

### Running Migrations

**Initial Setup** (one-time):

```bash
cd rootfs/webapp

# Install Alembic
pip install alembic

# Initialize Alembic
alembic init migrations

# Configure alembic.ini
# Set: sqlalchemy.url = sqlite:////run/acars/acars.db
```

**Applying Migrations**:

```bash
# Apply all migrations (including FTS)
alembic upgrade head

# Output:
# INFO  [alembic.runtime.migration] Running upgrade 002 -> 003, Enable FTS5 full-text search
```

**Checking Status**:

```bash
# See current migration version
alembic current

# Output:
# INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
# INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
# 003 (head)
```

**Rolling Back**:

```bash
# Rollback one migration (removes FTS)
alembic downgrade -1

# Rollback to specific version
alembic downgrade 002

# Rollback all migrations
alembic downgrade base
```

### Verifying FTS

**Check FTS Table Exists**:

```bash
sqlite3 /run/acars/acars.db << EOF
SELECT name, type FROM sqlite_master
WHERE name = 'messages_fts';
EOF

# Output:
# messages_fts|table
```

**Check Triggers Exist**:

```bash
sqlite3 /run/acars/acars.db << EOF
SELECT name FROM sqlite_master
WHERE type = 'trigger' AND name LIKE 'messages_fts_%';
EOF

# Output:
# messages_fts_insert
# messages_fts_delete
# messages_fts_update
```

**Test FTS Search**:

```bash
sqlite3 /run/acars/acars.db << EOF
SELECT tail, flight, text
FROM messages_fts
WHERE messages_fts MATCH 'UAL123'
LIMIT 5;
EOF

# Output:
# N12345|UAL123|...
# N67890|UAL123|...
```

**Test Trigger Sync**:

```bash
# Insert a test message
sqlite3 /run/acars/acars.db << EOF
INSERT INTO messages (timestamp, tail, flight, text)
VALUES (datetime('now'), 'TEST123', 'TST999', 'Test FTS sync');

-- Verify it appears in FTS index
SELECT tail, flight, text
FROM messages_fts
WHERE messages_fts MATCH 'TEST123';
EOF

# Output:
# TEST123|TST999|Test FTS sync
```

---

## Migrating from upgrade_db.py

### Step 1: Backup Database

```bash
cp /run/acars/acars.db /run/acars/acars.db.backup
```

### Step 2: Check Current FTS State

```bash
# Check if FTS already exists
sqlite3 /run/acars/acars.db << EOF
SELECT COUNT(*) FROM sqlite_master
WHERE name = 'messages_fts';
EOF

# If output is 1: FTS exists (from upgrade_db.py)
# If output is 0: FTS does not exist
```

### Step 3: Create Alembic Migration

If FTS already exists, the migration needs to be **non-conflicting**:

```python
# migrations/versions/003_enable_fts.py

def upgrade():
    """Enable FTS5 (idempotent - safe if already exists)"""

    # Check if FTS table exists
    connection = op.get_bind()
    result = connection.execute("""
        SELECT COUNT(*) FROM sqlite_master
        WHERE type='table' AND name='messages_fts'
    """)
    fts_exists = result.scalar() > 0

    if not fts_exists:
        # FTS doesn't exist - create everything
        column_list = ', '.join(FTS_COLUMNS)

        # Create virtual table
        op.execute(f"""
            CREATE VIRTUAL TABLE messages_fts USING fts5(
                {column_list},
                content=messages,
                content_rowid=id
            )
        """)

        # Create triggers
        # ... (trigger creation code)

        # Populate with existing data
        op.execute("INSERT INTO messages_fts(messages_fts) VALUES ('rebuild')")
    else:
        # FTS exists - verify triggers exist
        result = connection.execute("""
            SELECT COUNT(*) FROM sqlite_master
            WHERE type='trigger' AND name LIKE 'messages_fts_%'
        """)
        trigger_count = result.scalar()

        if trigger_count < 3:
            # Missing triggers - recreate them
            # ... (trigger creation code)
```

### Step 4: Run Migration

```bash
# Apply migration
alembic upgrade head

# Verify
alembic current
# Output: 003 (head)
```

### Step 5: Test FTS

```bash
# Test search
sqlite3 /run/acars/acars.db << EOF
SELECT COUNT(*) FROM messages_fts WHERE messages_fts MATCH 'test';
EOF

# Test trigger sync
sqlite3 /run/acars/acars.db << EOF
INSERT INTO messages (timestamp, text) VALUES (datetime('now'), 'trigger test');
SELECT COUNT(*) FROM messages_fts WHERE messages_fts MATCH 'trigger';
EOF
```

### Step 6: Remove upgrade_db.py

```bash
# Once verified working
rm rootfs/scripts/upgrade_db.py

# Update documentation
# Remove references to upgrade_db.py in README
```

---

## Other upgrade_db.py Functions

The legacy script also handled:

### 1. add_indexes()

**Purpose**: Create database indexes for performance

**Migration Approach**:

```python
# migrations/versions/004_add_indexes.py

def upgrade():
    """Add indexes for query performance"""
    op.create_index('idx_messages_timestamp', 'messages', ['timestamp'])
    op.create_index('idx_messages_tail', 'messages', ['tail'])
    op.create_index('idx_messages_flight', 'messages', ['flight'])
    op.create_index('idx_messages_icao', 'messages', ['icao'])
    op.create_index('idx_messages_station_id', 'messages', ['station_id'])
    op.create_index('idx_messages_freq', 'messages', ['freq'])

def downgrade():
    """Remove indexes"""
    op.drop_index('idx_messages_timestamp')
    op.drop_index('idx_messages_tail')
    op.drop_index('idx_messages_flight')
    op.drop_index('idx_messages_icao')
    op.drop_index('idx_messages_station_id')
    op.drop_index('idx_messages_freq')
```

**Benefits**: Alembic handles indexes natively (no raw SQL needed)

### 2. de_null()

**Purpose**: Fix NULL values (one-time data cleanup)

**Migration Approach**:

```python
# migrations/versions/005_fix_null_values.py

def upgrade():
    """Fix NULL values in freq column (one-time data migration)"""
    op.execute("UPDATE freqs SET freq = '0.0' WHERE freq IS NULL")

def downgrade():
    """Revert NULL fix (optional - may not be needed)"""
    pass  # Data migrations often can't be rolled back
```

### 3. normalize_freqs()

**Purpose**: Normalize frequency data (one-time data cleanup)

**Migration Approach**:

```python
# migrations/versions/006_normalize_frequencies.py

def upgrade():
    """Normalize frequency data format"""
    # Port logic from normalize_freqs()
    op.execute("""
        UPDATE freqs
        SET freq = TRIM(freq)
        WHERE freq LIKE '% %'
    """)

def downgrade():
    """Cannot revert normalization"""
    pass
```

### 4. optimize_db()

**Purpose**: Run VACUUM to reclaim space

**Approach**: Separate maintenance script (NOT a migration)

```python
# rootfs/scripts/maintenance.py

def vacuum_database():
    """Optimize database (VACUUM)

    Run periodically via cron or manually:
    python maintenance.py --vacuum
    """
    import sqlite3

    db_path = '/run/acars/acars.db'
    conn = sqlite3.connect(db_path)
    conn.execute('VACUUM')
    conn.close()

    print("Database optimized successfully")
```

**Why Not a Migration?**

- VACUUM is a maintenance operation, not a schema change
- Should be run periodically, not once
- Doesn't need rollback capability

### 5. prune_database()

**Purpose**: Delete old messages

**Approach**: Separate maintenance script (NOT a migration)

```python
# rootfs/scripts/maintenance.py

def prune_old_messages(days=30):
    """Delete messages older than N days

    Run periodically via cron or manually:
    python maintenance.py --prune --days 30
    """
    import sqlite3
    from datetime import datetime, timedelta

    db_path = '/run/acars/acars.db'
    cutoff = datetime.now() - timedelta(days=days)

    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute("""
        DELETE FROM messages
        WHERE timestamp < ?
    """, (cutoff,))

    deleted = cursor.rowcount
    conn.commit()
    conn.close()

    print(f"Deleted {deleted} messages older than {days} days")
```

---

## Best Practices

### 1. Always Use IF NOT EXISTS

Makes migrations idempotent (safe to run multiple times):

```python
# Good
op.execute("CREATE TABLE IF NOT EXISTS foo ...")
op.execute("CREATE TRIGGER IF NOT EXISTS bar ...")

# Bad (fails if table/trigger exists)
op.execute("CREATE TABLE foo ...")
op.execute("CREATE TRIGGER bar ...")
```

### 2. Always Implement downgrade()

Even if rollback is complex:

```python
def downgrade():
    """Rollback FTS setup"""
    # Drop triggers first (dependencies)
    op.execute("DROP TRIGGER IF EXISTS messages_fts_insert")
    op.execute("DROP TRIGGER IF EXISTS messages_fts_delete")
    op.execute("DROP TRIGGER IF EXISTS messages_fts_update")

    # Then drop table
    op.execute("DROP TABLE IF EXISTS messages_fts")
```

### 3. Test Migrations on Copy

Never run new migrations directly on production:

```bash
# Copy production database
cp /run/acars/acars.db /tmp/test.db

# Test migration
ACARS_DB=/tmp/test.db alembic upgrade head

# Verify results
sqlite3 /tmp/test.db "SELECT * FROM messages_fts LIMIT 1"

# If OK, run on production
alembic upgrade head
```

### 4. Document Complex Migrations

Add detailed docstrings:

```python
def upgrade():
    """Enable FTS5 full-text search

    Creates:
    - messages_fts virtual table (FTS5)
    - Triggers for INSERT/UPDATE/DELETE sync
    - Rebuilds FTS index from existing messages

    This migration replaces the legacy upgrade_db.py FTS setup.
    Safe to run on databases that already have FTS (idempotent).
    """
    # implementation
```

### 5. Keep Migrations Small

One conceptual change per migration:

```text
003_enable_fts.py      - FTS setup only
004_add_indexes.py     - Indexes only
005_fix_null_values.py - Data cleanup only
```

Easier to:

- Review
- Test
- Rollback
- Debug

---

## Troubleshooting

### Migration Failed Partway

**Symptom**: Migration started but crashed mid-execution

**Solution**:

```bash
# Check current state
alembic current

# If migration partially applied, rollback
alembic downgrade -1

# Fix the migration file
# Re-run
alembic upgrade head
```

### FTS Search Returns No Results

**Symptom**: `SELECT * FROM messages_fts WHERE messages_fts MATCH 'test'` returns empty

**Causes**:

1. FTS table not populated
2. Triggers not firing
3. FTS table corrupt

**Solution**:

```bash
# Rebuild FTS index
sqlite3 /run/acars/acars.db << EOF
INSERT INTO messages_fts(messages_fts) VALUES ('rebuild');
EOF

# Verify row count matches
sqlite3 /run/acars/acars.db << EOF
SELECT COUNT(*) FROM messages;
SELECT COUNT(*) FROM messages_fts;
EOF
# Counts should match
```

### Triggers Not Firing

**Symptom**: New messages don't appear in FTS index

**Solution**:

```bash
# Check triggers exist
sqlite3 /run/acars/acars.db << EOF
SELECT name FROM sqlite_master
WHERE type='trigger' AND name LIKE 'messages_fts_%';
EOF

# If missing, recreate
alembic downgrade 002
alembic upgrade 003
```

### Migration Conflicts

**Symptom**: `Target database is not up to date`

**Solution**:

```bash
# Check migration history
alembic history

# Check current version
alembic current

# Upgrade to head
alembic upgrade head
```

---

## Summary

### Key Takeaways

1. **Alembic Fully Supports FTS5** via raw SQL (`op.execute()`)
2. **Same Functionality** as `upgrade_db.py`, but better
3. **Version Controlled** migrations tracked in Git
4. **Rollback Support** via `downgrade()` functions
5. **Testable** on database copies before production
6. **Idempotent** safe to run multiple times

### Migration Checklist

- [x] Install Alembic
- [x] Create FTS migration with `op.execute()`
- [x] Implement `upgrade()` with virtual table + triggers
- [x] Implement `downgrade()` with cleanup
- [x] Test on database copy
- [x] Verify FTS search works
- [x] Document migration
- [x] Remove `upgrade_db.py`

### Next Steps

1. Implement Alembic FTS migration
2. Test thoroughly on dev database
3. Migrate production database
4. Retire `upgrade_db.py` script
5. Document new workflow for team
