# ACARS Hub v4.2 - Aircraft Session Architecture

This document describes the architecture decisions, data model, and implementation phases for
the v4.2 release. It is the authoritative reference for all agents working on v4.2 features.

## Why v4.2 Exists

Prior to v4.2, the frontend carried the full cognitive burden of message processing: grouping
messages by aircraft, deduplicating, merging multi-part sequences, pairing ACARS messages to
ADS-B targets, and culling stale groups. This worked but had fundamental limits:

- Historical context was lost on page load — the frontend only knew what arrived after connect
- ADS-B pairing was ephemeral — if an aircraft left and returned, prior messages were not linked
- Each connected client independently re-computed the same grouping logic
- There was no persistent record of where an aircraft was when it sent a message
- A new version of `@airframes/acars-decoder` silently left old messages undecoded

v4.2 moves all message intelligence to the backend and database, making the frontend a
stateful view of authoritative backend data rather than a computation engine.

## Phase 0: Documentation First

**Every v4.2 implementation session MUST begin here.**

Before writing any feature code, the implementing agent must update the agent-docs to reflect
the current state of the system. Documentation drift is what caused `ARCHITECTURE.md` and
`FEATURES.md` to describe a Python/Flask backend long after the system moved to Node.js.

### Documentation Audit Checklist

- [ ] `ARCHITECTURE.md` accurately describes the Node.js/Fastify/Drizzle/Socket.IO stack
- [ ] `ARCHITECTURE.md` data flow diagrams reflect the current TypeScript backend
- [ ] `ARCHITECTURE.md` database schema section reflects all tables including v4.2 additions
- [ ] `FEATURES.md` message processing section reflects that deduplication, merging, and
      pairing happen on the backend (not the frontend)
- [ ] `FEATURES.md` map section reflects backend-side ADS-B/ACARS pairing
- [ ] `AGENTS.md` overview section lists the correct tech stack
- [ ] `TESTING.md` test counts and coverage numbers are current

The agent should run `just ci` after documentation changes to ensure markdown linting passes.

## New Database Tables (Migration 10)

All four tables below are added in a single **Migration 10**. They are co-dependent v4.2
infrastructure and there is no reason to split them.

### `aircraft` — Flight Session Registry

Each row represents one flight session. Two appearances of the same aircraft are two rows.
This is intentional — see Session Lifecycle below.

```sql
CREATE TABLE aircraft (
    id             INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id     TEXT    NOT NULL UNIQUE,   -- UUID; FK target for messages.aircraft_id
    icao_hex       TEXT,                      -- ICAO 24-bit address (uppercase hex, e.g. "ABC123")
    callsign       TEXT,                      -- Flight number / callsign (e.g. "UAL123")
    tail           TEXT,                      -- Registration (e.g. "N12345")
    first_seen     INTEGER NOT NULL,          -- Unix timestamp ms
    last_seen      INTEGER NOT NULL,          -- Unix timestamp ms; updated on every contact
    is_active      INTEGER NOT NULL DEFAULT 1,-- 1 = session alive, 0 = timed out
    session_type   TEXT    NOT NULL DEFAULT 'adsb',
    -- 'adsb' | 'vdlm2' | 'hfdl' | 'adsc' | 'acars_only'
    -- Controls timeout threshold. See Session Timeout Thresholds below.
    pairing_method TEXT
    -- 'hex' | 'callsign' | 'tail' | 'acars_only' — how the session was first established
);

CREATE INDEX idx_aircraft_icao_hex   ON aircraft(icao_hex);
CREATE INDEX idx_aircraft_callsign   ON aircraft(callsign);
CREATE INDEX idx_aircraft_tail       ON aircraft(tail);
CREATE INDEX idx_aircraft_is_active  ON aircraft(is_active);
CREATE INDEX idx_aircraft_last_seen  ON aircraft(last_seen);
```

`messages.aircraft_id` (added in Migration 8, previously unused) links to `aircraft.session_id`.

### `aircraft_positions` — Smoothed Position History

Stores a filtered subset of ADS-B position fixes per session. Not every 5-second poll is
stored — see Position Smoothing below.

```sql
CREATE TABLE aircraft_positions (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id  TEXT    NOT NULL REFERENCES aircraft(session_id) ON DELETE CASCADE,
    timestamp   INTEGER NOT NULL,   -- Unix timestamp ms
    lat         REAL    NOT NULL,
    lon         REAL    NOT NULL,
    altitude    INTEGER,            -- feet, barometric
    heading     REAL,               -- degrees true
    speed       REAL,               -- knots ground speed
    UNIQUE(session_id, timestamp)
);

CREATE INDEX idx_positions_session_time ON aircraft_positions(session_id, timestamp);
```

### `decoded_messages` — Decoded Text Storage

Stores the output of `@airframes/acars-decoder` per message, along with the decoder version
that produced it. This enables version-aware re-processing. See Decoder Re-processing below.

```sql
CREATE TABLE decoded_messages (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    message_uid     TEXT    NOT NULL UNIQUE
                            REFERENCES messages(uid) ON DELETE CASCADE,
    decoder_version TEXT    NOT NULL,
    decode_level    TEXT    NOT NULL CHECK(decode_level IN ('full', 'partial', 'none')),
    decoder_name    TEXT,
    decoded_json    TEXT,   -- NULL when decode_level = 'none'
    decoded_at      INTEGER NOT NULL
);

CREATE INDEX idx_decoded_version ON decoded_messages(decoder_version);
CREATE INDEX idx_decoded_level   ON decoded_messages(decode_level);
```

Rows with `decode_level = 'none'` are stored intentionally. Without them, there is no way
to distinguish "never tried" from "tried and could not decode" during re-processing sweeps.

### `system_config` — Persistent Key-Value Store

General-purpose configuration table for values that must survive restarts and are not
appropriate for environment variables.

```sql
CREATE TABLE system_config (
    key        TEXT    PRIMARY KEY,
    value      TEXT    NOT NULL,
    updated_at INTEGER NOT NULL
);
```

**Keys used by v4.2**:

| Key                               | Purpose                                                                   |
| --------------------------------- | ------------------------------------------------------------------------- |
| `acars_decoder_installed_version` | Version last seen at startup; triggers re-processing on change            |
| `acars_decoder_reprocess_status`  | `idle` / `running` / `completed` / `failed`                               |
| `acars_decoder_reprocess_cursor`  | Last `messages.id` completed during in-progress sweep (resume on restart) |

### Foreign Keys

SQLite does not enforce foreign keys by default. `better-sqlite3` requires:

```typescript
db.pragma("foreign_keys = ON");
```

This must be set on every connection in `db/client.ts`. Verify it is present before
implementing cascading deletes.

## Session Lifecycle

### Session Types and Timeout Thresholds

A session is considered the "same flight" as long as a contact arrives within the timeout
window. After the timeout, any new contact creates a new session row, even if `icao_hex`,
`callsign`, and `tail` are identical.

| `session_type` | Timeout    | Rationale                                                |
| -------------- | ---------- | -------------------------------------------------------- |
| `adsb`         | 20 minutes | Local Mode S; aircraft lands or leaves range quickly     |
| `vdlm2`        | 45 minutes | Slightly longer range; taxi and gate messages common     |
| `hfdl`         | 6 hours    | Oceanic; multi-hour gaps between position reports normal |
| `adsc`         | 12 hours   | Polar/oceanic; very long gaps by design                  |
| `acars_only`   | 90 minutes | No position data; conservative to avoid false splits     |

The `session_type` is set to the most authoritative source that has contributed to the session.
Priority: `adsb` > `vdlm2` > `hfdl` > `adsc` > `acars_only`. If an `acars_only` session
later receives ADS-B data, `session_type` is upgraded and `pairing_method` is updated.

### Session Matching Algorithm

On every inbound message or ADS-B position, the session service runs:

```text
1. Query active sessions (is_active = 1) matching any of: icao_hex, callsign, tail
2. For each candidate, compute elapsed = now - last_seen
3. If elapsed < TIMEOUT[session_type]:
     → Update last_seen, enrich identifiers if new data, return session_id
4. If no live match:
     → Create new session, set session_type from message source
     → Return new session_id
```

Matching priority is `icao_hex` > `callsign` > `tail`. If a session is found by callsign
but the incoming data includes a new `icao_hex` not yet on that session, update the session
row with the hex. This is "session enrichment" — identifiers accumulate over a session's life.

### Session Expiry

A background task (extending the existing `scheduler.ts`) runs every 5 minutes and marks
sessions inactive:

```text
UPDATE aircraft SET is_active = 0
WHERE is_active = 1
  AND last_seen < (now - TIMEOUT[session_type])
```

Inactive sessions are retained in the database for historical queries. They are never deleted
by the expiry process.

### Callsign Reuse Edge Case

Airlines reuse flight numbers daily. `UAL123` on Monday is a different aircraft than `UAL123`
on Tuesday. The timeout logic handles routine cases, but a defensive check applies when:

- A session exists with a matching callsign
- Elapsed time is > 80% of the session's timeout threshold
- The session has no `icao_hex` (callsign-only match)

In this case, treat the incoming contact as a new session. Log a warning. This avoids
erroneously extending a stale callsign-only session.

## Retroactive Pairing

When a new ADS-B target appears, the backend checks for historical ACARS messages that
should belong to this session but arrived before the ADS-B signal was first received.

```text
1. New ADS-B contact creates or updates a session (session_id S, hex H, callsign C, tail T)
2. Query: SELECT uid FROM messages
          WHERE aircraft_id IS NULL
            AND msg_time > (first_seen - LOOKBACK_WINDOW)
            AND (icao = H OR flight = C OR tail = T)
3. For each match: UPDATE messages SET aircraft_id = S WHERE uid = ?
4. Emit `session_messages_updated` event with [session_id, [uids]]
```

`LOOKBACK_WINDOW` is 60 minutes for `adsb` sessions. For `hfdl`/`adsc` sessions the window
scales with the session timeout.

Retroactive pairing is also run on session enrichment — when a new identifier (e.g., `icao_hex`)
is added to an existing session, the query runs again with the newly available identifier.

## Decoded Message Storage and Re-processing

### At Ingest Time

When a new ACARS message arrives and is stored, the backend:

1. Calls `@airframes/acars-decoder` with the message text and label
2. Writes one row to `decoded_messages` (with `decode_level = 'none'` if undecoded)
3. Sets `decoded_at` and `decoder_version` from the installed package version
4. The `decodedText` field on the outbound socket message is populated from this row

The `enrichMessage()` function in `formatters/enrichment.ts` is the correct integration point.
It already calls the decoder inline. Post-v4.2, it will write the result to `decoded_messages`
and subsequent retrievals will JOIN rather than re-decode.

### Version Detection at Startup

```typescript
// At startup, after DB is initialized
const installed = getInstalledDecoderVersion(); // from @airframes/acars-decoder/package.json
const stored = systemConfig.get("acars_decoder_installed_version");

if (installed !== stored) {
  logger.info("acars-decoder version change detected", { stored, installed });
  systemConfig.set("acars_decoder_installed_version", installed);
  decoderReprocessor.schedule();
}
```

A simple string equality check is sufficient. Semantic versioning comparison is unnecessary —
any version change (including a downgrade) warrants re-processing to ensure consistency.

### Background Reprocessor

The reprocessor is a low-priority background service added to the scheduler. It must not
starve the event loop while 100k+ messages are being re-processed.

**Processing order** (most likely to benefit from a new decoder version first):

1. Messages with no row in `decoded_messages` (legacy data, never processed)
2. Messages where `decode_level = 'none'` and `decoder_version != installed`
3. Messages where `decode_level = 'partial'` and `decoder_version != installed`
4. Messages where `decode_level = 'full'` and `decoder_version != installed`

**Execution model**:

- Batch size: 250 messages per iteration
- Yield between batches: `await new Promise(resolve => setImmediate(resolve))`
- Persist cursor to `system_config.acars_decoder_reprocess_cursor` after each batch
- On restart, read cursor and resume from that `messages.id`
- On completion, set `acars_decoder_reprocess_status = 'completed'`

**When a decode changes**:

If re-processing produces a different `decode_level` or `decoded_json` from what is stored,
the reprocessor updates the row and emits a `message_decode_updated` Socket.IO event:

```typescript
// Server → client
socket.emit("message_decode_updated", {
  uid: string;
  decodedText: DecodedText | null;
});
```

Clients update any matching message currently in their view. This lets users watching Live
Messages see decodes improve in real time as the reprocessor runs.

## Backend Processing Pipeline Changes

### What Moves from Frontend to Backend

| Concern                                  | Current location                         | v4.2 location                                   |
| ---------------------------------------- | ---------------------------------------- | ----------------------------------------------- |
| `@airframes/acars-decoder` text decoding | Backend (`enrichment.ts`) — already done | Backend (now persisted to DB)                   |
| Duplicate detection (3 strategies)       | Frontend                                 | Backend (at ingest, before DB write)            |
| Multi-part message merging (AzzA, AAAz)  | Frontend                                 | Backend (accumulate parts, write merged)        |
| Message grouping by identifier           | Frontend                                 | Backend (replaced by session service)           |
| ADS-B / ACARS pairing                    | Frontend                                 | Backend (session service + retroactive pairing) |
| Culling decisions                        | Frontend                                 | Backend (controls what is sent per client)      |
| Alert term matching                      | Partially backend                        | Fully backend                                   |

The frontend becomes a **render target**: it receives pre-processed, pre-grouped,
pre-decoded data and renders it. It performs no business logic on messages.

### New Ingest Pipeline

```text
TCP message arrives
  → MessageQueue.push()
  → Dedup check (3 strategies, against recent DB messages)
      → Duplicate: increment counter, do not insert new row
      → Multi-part: accumulate in memory, merge when complete, then continue
  → DB insert (messages table)
  → Session matching (find or create aircraft session, set aircraft_id)
  → enrichMessage() — field normalization, airline lookup, ground station lookup
  → decoded_messages write (decoder output + version)
  → Alert term matching → alert_matches write if matched
  → Broadcast session_messages_updated to all clients
```

### Position Smoothing

Not every 5-second ADS-B poll is stored in `aircraft_positions`. A new position row is
written only when **both** conditions are met:

- At least 30 seconds have elapsed since the last stored position for this session
- Position has changed by > 500 meters OR heading has changed by > 15 degrees

A fallback ensures at least one position is stored every 5 minutes during sustained cruise,
preventing large gaps in the trail for straight-line segments.

This approach produces dense trails through turns and sparse but present trails during
cruise — ideal for rendering flight paths without excessive storage.

## Socket.IO Protocol Changes

### New Server → Client Events

```typescript
// Full session object: sent on connect and when session state changes significantly
"aircraft_session": {
  sessionId: string;
  icaoHex: string | null;
  callsign: string | null;
  tail: string | null;
  sessionType: string;
  isActive: boolean;
  firstSeen: number;
  lastSeen: number;
  messages: AcarsMsg[];       // Most recent N messages for this session
  alertCount: number;
  hasAlerts: boolean;
}

// Incremental update: new or updated messages for an existing session
"session_messages_updated": {
  sessionId: string;
  messages: AcarsMsg[];       // Only the new/changed messages
}

// New position(s) for an active session
"session_position_update": {
  sessionId: string;
  positions: Array<{ timestamp: number; lat: number; lon: number;
                     altitude?: number; heading?: number; speed?: number }>;
}

// A previously unpaired message was retroactively linked to a session
"session_paired": {
  sessionId: string;
  messageUids: string[];
}

// Session timed out (is_active set to 0)
"session_ended": {
  sessionId: string;
}

// Full state dump matching current client filters; sent on connect or after filter change
"initial_state": {
  sessions: AircraftSession[];
  filters: LiveFilters;
}

// Decoder re-processing updated a message's decoded text
"message_decode_updated": {
  uid: string;
  decodedText: DecodedText | null;
}

// Re-processing progress (for status/settings display)
"decoder_reprocess_progress": {
  status: "running" | "completed" | "failed";
  processed: number;
  total: number;
  currentPass: "unprocessed" | "none" | "partial" | "full";
}
```

### New Client → Server Events

```typescript
// Request fresh initial_state with given filters
"request_state": {
  filters: LiveFilters;
}

// Update active filter subscription; backend responds with initial_state
"set_live_filters": {
  filters: LiveFilters;
}

// Request full position trail + all messages for one session (for map/search drill-down)
// Consider HTTP GET /api/aircraft/:sessionId/history instead of Socket.IO for this
"request_aircraft_history": {
  sessionId: string;
}
```

### HTTP Endpoints (Fastify)

Aircraft history is a one-shot request/response, not a stream. Fastify HTTP fits better
than Socket.IO for this pattern:

```text
GET /api/aircraft/:sessionId/history
  → Returns: { session, positions[], messages[] }

GET /api/aircraft?icao=&callsign=&tail=
  → Returns: all sessions (active and historical) matching identifiers
```

### LiveFilters Type

```typescript
interface LiveFilters {
  decoderTypes?: string[]; // ['acars', 'vdlm2', 'hfdl', ...]
  labelsOnly?: string[]; // Only messages with these labels
  alertsOnly?: boolean;
  hasTextOnly?: boolean;
  adsbPairedOnly?: boolean; // Only sessions with ADS-B data
}
```

When a client emits `set_live_filters`, the backend marks all sessions matching the old
filter as "unsubscribed" for that client and sends a fresh `initial_state` for the new filter.
The frontend clears its session map and re-populates from `initial_state`.

## Frontend Changes

### What the Frontend No Longer Does

- No message grouping logic (`messageCulling.ts` → deleted or gutted)
- No duplicate detection
- No multi-part merging
- No ADS-B/ACARS pairing
- No `@airframes/acars-decoder` calls (messages arrive pre-decoded)

### New AppStore Shape

```typescript
// Replaces MessageGroup-based structure
interface AppStore {
  sessions: Map<string, AircraftSession>; // keyed by session_id
  adsbPositions: Map<string, Aircraft>; // keyed by icao_hex (live map positions)
  filters: LiveFilters;
  connectionState: "connected" | "disconnected" | "reconnecting";
  // ... alerts, terms, status unchanged
}
```

### State-Based Filtering

Filter changes follow this flow:

1. User changes a filter in the UI
2. Frontend emits `set_live_filters` with new filters
3. Frontend clears its sessions map immediately (shows loading state)
4. Backend sends `initial_state` with sessions matching the new filter
5. Frontend populates sessions map from `initial_state`
6. Backend continues sending incremental updates (`session_messages_updated`, etc.)

This eliminates client-side filter logic entirely. The frontend never needs to decide which
messages to show or hide — the backend sends only what matches the current filter.

## Implementation Phases

Each phase is independently deployable and testable. Tests MUST be written as part of each
phase, not deferred. Every phase that touches existing behavior requires regression tests.

### Phase 0: Documentation Audit

Update `ARCHITECTURE.md`, `FEATURES.md`, and `AGENTS.md` to accurately describe the current
Node.js backend. Fixes the Python/Flask drift before new features compound the problem.

**Deliverables**: Updated docs, `just ci` passes

### Phase 1: Database Migration 10

Add `aircraft`, `aircraft_positions`, `decoded_messages`, and `system_config` tables.
Enable `PRAGMA foreign_keys = ON` in `db/client.ts`.

**Deliverables**:

- `migration10_v42_tables()` function following the existing pattern in `migrate.ts`
- Tests: fresh DB migration, idempotency (run twice), schema verification for all 4 tables,
  `ON DELETE CASCADE` verified for `decoded_messages` → `messages`

### Phase 2: System Config Service

A typed wrapper around `system_config` table reads/writes. Used by all subsequent phases.

**Deliverables**:

- `src/services/system-config.ts` with `get(key)`, `set(key, value)` functions
- Tests: get/set round-trip, missing key returns null, updated_at is set

### Phase 3: Decoded Messages Pipeline

Replace inline `enrichDecodedText()` decode-and-attach with store-then-retrieve approach.
Decoder version detection at startup triggers re-processing if version changed.

**Deliverables**:

- `decoded_messages` written at ingest (new messages and on first retrieval of legacy messages)
- Message retrieval JOINs `decoded_messages` instead of re-decoding
- Version comparison at startup in `server.ts`
- Tests: new message creates `decoded_messages` row, retrieval uses stored decode,
  version change triggers reprocessor schedule

### Phase 4: Background Decoder Reprocessor

Low-priority background service that re-processes `decoded_messages` in priority order when
a new decoder version is detected.

**Deliverables**:

- `src/services/decoder-reprocessor.ts`
- Cursor-based batch processing (250 messages per batch, yields between batches)
- Resume on restart from `system_config` cursor
- `decoder_reprocess_progress` and `message_decode_updated` socket events
- Tests: processes in correct priority order, cursor is persisted, resumes after restart,
  emits correct socket events when decode changes

### Phase 5: Session Service

Core session management engine. The most complex service in v4.2 and the foundation for
everything that follows.

**Deliverables**:

- `src/services/session-service.ts`
- `findOrCreateSession(identifiers)` — matches active sessions or creates new
- `expireStaleSession()` — called by scheduler
- `enrichSession(sessionId, newIdentifiers)` — adds newly discovered identifiers
- Session type timeout table
- Callsign reuse edge case handling
- Tests: this service requires comprehensive coverage including regression tests for every
  edge case in the matching algorithm (same hex different callsign, callsign reuse timing,
  session enrichment, expiry boundary conditions)

### Phase 6: ADS-B Position Storage

Wire `AdsbPoller` data events into the session service and position writer.

**Deliverables**:

- `AdsbPoller` `data` handler calls session service for each aircraft
- Position smoothing logic (500m / 15-degree / 5-minute rules)
- `aircraft_positions` rows written for qualifying positions
- `session_position_update` socket events emitted
- Tests: position smoothing thresholds, no duplicate positions, session created on first
  ADS-B contact, existing session updated on subsequent contact

### Phase 7: ACARS Message Session Linking

Wire inbound ACARS message pipeline into session service. Set `aircraft_id` at ingest time.

**Deliverables**:

- Session matching called after DB insert in message ingest path
- `messages.aircraft_id` set for all new messages
- `session_messages_updated` socket event emitted
- Tests: message linked to existing session, message creates new `acars_only` session,
  session upgraded from `acars_only` to `adsb` when ADS-B arrives

### Phase 8: Retroactive Pairing

When a new session is created or enriched with a new identifier, scan historical unlinked
messages.

**Deliverables**:

- `retroactivelyPairMessages(sessionId)` function in session service
- Called on session creation and on session enrichment (new identifier added)
- `session_paired` socket event emitted with affected UIDs
- Lookback window respects session type
- Tests: messages within window are linked, messages outside window are not,
  pairing by hex overrides prior callsign-only pairing

### Phase 9: Deduplication and Multi-Part Merging (Backend)

Move the three deduplication strategies and multi-part accumulation from frontend to backend.
These currently live in frontend utilities (`messageCulling.ts`, store logic).

**Deliverables**:

- `src/services/message-processor.ts` with dedup and merge logic
- Full-field match, text-only match, AzzA/AAAz multi-part detection
- Multi-part accumulator in memory with 8-second window
- Tests: all three dedup strategies, multi-part merge sequence, timeout expiry,
  station separation (ACARS vs VDLM2 kept separate)

### Phase 10: Protocol Rollout and Frontend Adapters

Add the new socket events to `acarshub-types/src/socket.ts` and implement minimal frontend
adapters that accept the new events and populate the new `sessions`-based AppStore.

At this phase, both old and new events coexist. The frontend can receive either. This allows
incremental testing without breaking the live UI.

**Deliverables**:

- New event types in `acarshub-types`
- `initial_state`, `aircraft_session`, `session_messages_updated`, `session_position_update`,
  `session_paired`, `session_ended` handlers in frontend
- `sessions: Map<string, AircraftSession>` added to AppStore
- Tests: each new socket event correctly updates AppStore

### Phase 11: Frontend Refactor

Remove client-side message processing. The frontend no longer groups, deduplicates, merges,
or pairs. Old message processing utilities are deleted or reduced to pure display helpers.

**Deliverables**:

- `messageCulling.ts` deleted (or reduced to type definitions only)
- Grouping logic removed from AppStore
- `set_live_filters` and `request_state` emitted on filter change
- `initial_state` replaces old message batch on connect
- Regression tests for all previously-passing frontend tests (ensure nothing broke)

### Phase 12: State-Based Filtering

Implement the full filter subscription model. Filter changes clear the frontend state and
request fresh data from the backend.

**Deliverables**:

- `set_live_filters` handler in backend socket handlers
- Per-client filter state tracked in socket handler (in-memory, keyed by socket ID)
- `initial_state` generated per-client based on their current filter
- Frontend emits `set_live_filters` on filter change, shows loading state during transition
- Tests: filter change sends correct subset, reconnect restores last filter, empty filter
  returns all sessions

### Phase 13: Map History Trails

Render per-session position history on the Live Map as a polyline behind each aircraft
marker. Include pushpin markers at positions where messages were received.

**Deliverables**:

- `GET /api/aircraft/:sessionId/history` HTTP endpoint in Fastify
- Map page calls this endpoint on aircraft marker click (alongside loading messages)
- Polyline rendered in MapLibre using Catppuccin theme colors
- Message-position correlation: messages with known position (from ADS-B at time of receipt)
  shown as markers on the trail
- Position interpolation for messages received between known fixes (stored as
  `position_interpolated = true` on the message, shown with dashed marker style)
- Tests: HTTP endpoint returns correct schema, polyline data is ordered by timestamp,
  interpolated positions flagged correctly

### Phase 14: Search with Aircraft History

From search results, allow navigating to a map view showing the full session history for
a matched aircraft.

**Deliverables**:

- Search results include `session_id` on each message (already present via `aircraft_id`)
- "View on Map" button in search results navigates to `/live-map?session=SESSION_ID`
- Live Map page reads `?session` query param and pre-loads that session's history
- Multi-session view: search by tail/hex returns all historical sessions; map shows all trails
  with timeline selector to highlight individual sessions
- Tests: URL param loads correct session, multi-session query groups by tail/hex correctly

## Additional Features (Post-Phase 14)

These features were identified during planning and should be tracked for future implementation
but are not part of the initial v4.2 scope:

**Session Event Log**: Lightweight event log per session — "entered ADS-B range",
"callsign resolved", "session merged", "left range". Timeline display per aircraft.

**Flight Arc Visualization**: When a session has `depa`/`dsta` from ACARS messages, draw the
great-circle route on the map alongside the observed trail. Provides context for where the
aircraft came from and where it's going.

**Coverage Heatmap**: Aggregate `aircraft_positions` with time-decay weighting to generate an
antenna coverage heatmap as a MapLibre layer. Useful for diagnostics.

**Multi-Session Aircraft View**: Group all historical sessions for a given tail/hex and display
them together on a single map with per-session color coding.

**Session Quality Score**: Confidence indicator on each session — low for callsign-only
matches, high when hex is confirmed. Surface in the UI to indicate pairing certainty.

**Signal Strength at Position**: Correlate `level` field on messages with `aircraft_positions`
at time of receipt to produce a signal-vs-distance plot per frequency.

## Architecture Invariants

These rules must be preserved throughout v4.2 implementation:

1. **The backend is the source of truth.** The frontend renders; it does not compute.
2. **Sessions are immutable once created.** A new flight is always a new row, even for the
   same aircraft. Historical data must not be retroactively re-assigned to different sessions.
3. **Cascade deletes are the only pruning mechanism for `decoded_messages`.** Never delete
   from `decoded_messages` directly. Delete from `messages` and let the cascade handle it.
4. **The decoder reprocessor is non-blocking.** It must yield between batches. A slow
   re-process must never delay message ingestion or socket broadcasts.
5. **All new services follow the singleton pattern** used by `MessageQueue`, `AdsbPoller`, etc.
   Export a `getXxx()` factory and a `destroyXxx()` for test cleanup.
6. **Every phase ships with tests.** See `TESTING.md` and the Testing Mandate in `AGENTS.md`.
